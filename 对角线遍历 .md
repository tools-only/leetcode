 # 对角线遍历 

给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。

**示例:**

```
输入:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]

输出:  [1,2,4,7,5,3,6,8,9]

解释:
```

**说明:**

1. 给定矩阵中的元素总数不会超过 100000 。

**Python3**   

思路是：根据行和列确定遍历顺序，奇数次迭代从下往上，偶数次迭代从上往下（从0开始计数），迭代的总次数是行和列长度和-1。然后分别确定奇偶次迭代时下标顺序即可。第一次提交时打算用异常处理来跳过主对角线之后存在的数组越界问题，结果超时了。。 （异常处理的确会耗时一些，我线下写了测试样例，1亿次循环如果加上`try-except`时间为`30.27s`，而`for循环+if`时间为`8.3s`）

```python
class Solution(object):
    def findDiagonalOrder(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: List[int]
        """
        if matrix == []:
            return []
        res = []
        iter_num = len(matrix) + len(matrix[0]) - 1
        for i in range(iter_num):
                direction = i % 2 # 奇数方向向下，偶数方向向上
                if direction == 0: # 偶数次迭代，从下往上遍历
                    for k in range(i, -1, -1):
                        try:
                            res.append(matrix[k][i-k])
                        except:
                            pass
                else: # 奇数次迭代，从上往下遍历
                    for k in range(i, -1, -1):
                        try:
                            res.append(matrix[i-k][k])
                        except:
                            pass
    return res
```

发现`if`要快一些之后，我写了个简单的`criterion`函数，用来判断下标是否合理 ，结果仍然超时。 

```python
class Solution(object):  
    def findDiagonalOrder(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: List[int]
        """
        if matrix == []:
            return []
        res = []
        row = len(matrix)
        col = len(matrix[0])
        iter_num = row + col - 1                     
        for i in range(iter_num):
                direction = i % 2 # 奇数方向向下，偶数方向向上
                if direction == 0: # 偶数次迭代，从下往上遍历
                    for k in range(i, -1, -1):
                        if self.criterion(k, i-k, row-1, col-1): # k对应
                            res.append(matrix[k][i-k])
                        else:
                            continue
                else: # 奇数次迭代，从上往下遍历
                    for k in range(i, -1, -1):
                        if self.criterion(i-k, k, row-1, col-1):
                            res.append(matrix[i-k][k])
                        else:
                            continue    
        return res
    
    def criterion(self, x, y, row, col):
        if x <= row and y <= col:
            return True
        else:
            return False
```

最终测试通过的版本  

```python
class Solution(object):  
    def findDiagonalOrder(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: List[int]
        """
        if matrix == []:
            return []
        res = []
        r, c = 0, 0
        row, col = len(matrix), len(matrix[0])
        iter_num = row + col - 1                     
        for i in range(row*col): # 元素总个数
            res.append(matrix[r][c])
            if (r + c) % 2 == 0: # 偶数次迭代
                if c == col - 1: # 约束列下标
                    r += 1
                elif r == 0: # 约束行下标
                    c += 1
                else:
                    c += 1
                    r -= 1
            else:
                if r == row - 1:
                    c += 1
                elif c == 0:
                    r += 1
                else:
                    r += 1
                    c -= 1
        return res
```

